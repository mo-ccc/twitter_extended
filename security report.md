# Security
#### Mohammed Ahmad
---

The security of user information is of great importance. As an added benefit of using flask - a python microframework - and sqlalchemy - an object relational mapping framework - to provide users with an interactive web experience; the frameworks also protect the information of users by together sanitising user input and mitigating sql injection. Because the application will take input from users this added benefit is extremely beneficial.

### Input sanitisation
Input sanitisation is the process in which the user input is taken and is parsed of anything that could trigger unusual functioning. In python this includes the special characters like ",' and \. When these are present in an input python will read them as part of the code and with the correct combination and execution, malicious parties can get python to run code that they want it to run. Alternatively users can inject javascript into the database that can run on other users' machines. The implications of this is that the attacker can use python and javascript to pilfer or corrupt data as well as create backdoors and expose more vulnerabilities.

Luckily flask automatically reads all form data as raw string literals and so there is no need for the special characters to be escaped. This is by default the way inputs are read in python3 and thus there is no confusion for the developer. Furthermore flask also provides the user with a function that converts user input into a file system safe format so that files can be easily stored on the system without causing breaking errors. Therefore there is no risk of python injection from end users.

Flask, by default, configures Jinja2 to handle cross-site scripting by automatically escaping all user created data. This is thus a very effective form of santisation and its inclusion in flask is a very good thing. However, this even includes input from the server side which as a result prevented the twitter_extended application from adding html from an input that functions executed on. To workaround this instead of disabling the escaping of inputs it was decided that javascript would instead be used to create html elements when the page loaded. Because this work around exists without reducing security flask's inclusion of the auto escaping feature is overall an effective solution.

Flask can also be configured to use marshmallow. A serialization/deserialization library that ensures that the data passed to python is valid.

## Mitigating SQL injection
SQL injection is a very devastating attack which can allow malicious actors to directly execute sql code through the inputs of the application. This is due to a lack of security between the bridge from the api programming language to the sql database language. The implications of this means that attackers can view or delete the entire database with just a single well crafted input.

ORM's resolve this issue by being the bridge between the api language and the database language, performing all the required validation and sanitisation to make the data safe, before forwarding the data to the database. Because the ORM has been developed with the efforts of many developers that have familiarised themselves with the possibilties of sql injection; the ORM that they've developed is extremely robust and handles just about every possible weak point. For the developer this means they do not have to manually research and create code to handle sql injection and as aresult their job is made easier and there is no room for human error.

SQLalchemy provides this very service by interfacing directly with flask. Instead of simply creating a insert statement that will insert data into the database an insert statement is automatically created by sqlalchemy when an initialized sqlalchemy model is added to a session in the orm. The statement then executes and if an error occurs within the database the ORM will raise that error in python3, adding even more security to the process. On the other hand SQLalchemy takes away from the traditional style of working with a database and abstracts it to the point where the developer does not work with sql except under very special cirucmstances. This can be seen as both a good and bad thing as the developer might not have any understanding of how the database works but is still able to get by with the orm.